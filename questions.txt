1. You are building an image processing system and you have a fist prototype:

    // Some class that contains an image - the internals of the class are not relevant.
    class Image;

    // Get an image from a device, write to a device.
    Image getImageFromDevice();
    void outputImageToDevice(Image);


    // The details of these functions are not important.
    // An Image comes in, a processed image goes out
    Image applyTransform0(Image);
    Image applyTransform1(Image);
    Image applyTransform2(Image);


    void processImages()
    {
        while(true)
        {
	    auto image = getImageFromDevice();

            image = applyTransform0(image);
	    image = applyTransform1(image);
            image = applyTransform2(image);

            outputImageToDevice(image);
        }
    }


You quickly realize that your system is not scaling very well. You want to transform
this processing sequence into a parallel pipeline where every stage in the pipeline
runs on its own thread.

How would you implement such a pipeline in C++? Ideally your implementation should
account for the fact that:

  - Your don't really know (or care) about what each stage does. You only need to call
    some function (e.g. the applyTransform methods) on some object (e.g. an Image) and
    then pass on the result.

  - At a later stage you may decide to add or remove processing steps; keep it flexible.

  - The users of your pipeline should not need to understand its internals. Try to keep
    the interface clean. For instance to build the pipeline you can have something like:

       Pipeline pipe;

       pipe.addStage(getImageFromDevice);
       pipe.addStage(applyTransform0);
       pipe.addStage(applyTransform1);
       pipe.addStage(outputImageToDevice);

       pipe.run();

  - It may happen that the device that you read from is slower than the one that you
    write to. Take care to avoid the pipeline to stall in this scenario.
